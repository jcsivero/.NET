// Game.h Añadimes descriptor heap  para samplers
 Microsoft::WRL::ComPtr<ID3D12DescriptorHeap>        m_sDescriptorHeap; // Descriptor HEap de Samplers

// Game.h include
#include "DDSTextureLoader.h"

 // Game.cpp en CreateMainInputFlowResources añadir la carga de la textura
m_mesh.meshTexture = std::make_unique<Mesh::Texture>();
m_mesh.meshTexture->Name = "tutorialTex";
m_mesh.meshTexture->Filename = L"tutorialtextura.dds";
DX::ThrowIfFailed(DirectX::CreateDDSTextureFromFile12(m_d3dDevice.Get(), m_commandList.Get(),
m_mesh.meshTexture->Filename.c_str(),
m_mesh.meshTexture->Resource,
m_mesh.meshTexture->UploadHeap));

//Game.cpp modificar el heap de descriptores y crear descriptores
 // El heap de descriptores para los buffers de constantes
    D3D12_DESCRIPTOR_HEAP_DESC cHeapDescriptor;
    cHeapDescriptor.NumDescriptors = 2;
    cHeapDescriptor.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
    cHeapDescriptor.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
    cHeapDescriptor.NodeMask = 0;

    m_d3dDevice->CreateDescriptorHeap(&cHeapDescriptor, IID_PPV_ARGS(&m_cDescriptorHeap));

    /* Tarea 3: Crear un heap de descriptores para samplers*/
    D3D12_DESCRIPTOR_HEAP_DESC descHeapSampler = {};
    descHeapSampler.NumDescriptors = 1;
    descHeapSampler.Type = D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER;
    descHeapSampler.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;

    DX::ThrowIfFailed(m_d3dDevice->CreateDescriptorHeap(&descHeapSampler, IID_PPV_ARGS(&m_sDescriptorHeap)));


    /* Tarea 4: crear un descriptor para el buffer de constantes*/
    // Ahora el descriptor de la vista buffer de constantes
    D3D12_GPU_VIRTUAL_ADDRESS cAddress = m_vConstantBuffer->GetGPUVirtualAddress();
    D3D12_CONSTANT_BUFFER_VIEW_DESC cDescriptor;
    cDescriptor.BufferLocation = cAddress;
    cDescriptor.SizeInBytes = CalcConstantBufferByteSize(sizeof(vConstants));
    m_cDescriptorSize = m_d3dDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
    // Creamos el descriptor y lo colocamos al principio del heap de descriptores.
    m_d3dDevice->CreateConstantBufferView(&cDescriptor, m_cDescriptorHeap->GetCPUDescriptorHandleForHeapStart());

    /* Tarea 5 Creamos un descriptor SRV para la textura*/
    // Obtenemos un handle para el descriptor.
    CD3DX12_CPU_DESCRIPTOR_HANDLE hDescriptor(
        m_cDescriptorHeap->GetCPUDescriptorHandleForHeapStart()
    );
    hDescriptor.Offset(1, m_cDescriptorSize);
    D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
    srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
    srvDesc.Format = m_mesh.meshTexture->Resource->GetDesc().Format;
    srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
    srvDesc.Texture2D.MostDetailedMip = 0;
    srvDesc.Texture2D.MipLevels = m_mesh.meshTexture->Resource->GetDesc().MipLevels;
    srvDesc.Texture2D.ResourceMinLODClamp = 0.0f;
    m_d3dDevice->CreateShaderResourceView(m_mesh.meshTexture->Resource.Get(), &srvDesc, hDescriptor);

    /* Tarea 6 Creamoes un descriptor para el sampler*/
    D3D12_SAMPLER_DESC samplerDesc = {};
    samplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
    samplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
    samplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
    samplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
    samplerDesc.MinLOD = 0;
    samplerDesc.MaxLOD = D3D12_FLOAT32_MAX;
    samplerDesc.MipLODBias = 0.0f;
    samplerDesc.MaxAnisotropy = 1;
    samplerDesc.ComparisonFunc = D3D12_COMPARISON_FUNC_ALWAYS;
    m_d3dDevice->CreateSampler(&samplerDesc, m_sDescriptorHeap->GetCPUDescriptorHandleForHeapStart());
 
 
 // Game.cpp Modificar la roor signature
 
 CD3DX12_ROOT_PARAMETER rootParameters[3]; //Array de root parameters // CBT
    // Creamos un rango de tablas de descriptores
    CD3DX12_DESCRIPTOR_RANGE descRange[3]; // CBT
    descRange[0].Init(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, 1, 0); //1 CB to slot 0
    descRange[1].Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0); //1 Texture to Slot 0
    descRange[2].Init(D3D12_DESCRIPTOR_RANGE_TYPE_SAMPLER, 1, 0); // 1 Sampler to Slot 0


    rootParameters[0].InitAsDescriptorTable(1, // Número de rangos 
        &descRange[0],D3D12_SHADER_VISIBILITY_ALL); 
    rootParameters[1].InitAsDescriptorTable(1, // Número de rangos 
        &descRange[1], D3D12_SHADER_VISIBILITY_PIXEL);
    rootParameters[2].InitAsDescriptorTable(1, // Número de rangos 
        &descRange[2], D3D12_SHADER_VISIBILITY_PIXEL);

/* Tarea 2: Creamos una descripción de la root signature y la serializamos */
    // Descripción de la root signature //CBT
    CD3DX12_ROOT_SIGNATURE_DESC rsDescription(3, rootParameters, 0, nullptr, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);

	
	
 
 // Game.cpp método Clear. Modificar el array de heaps
 
     ID3D12DescriptorHeap* arrayHeaps[] = { m_cDescriptorHeap.Get(), m_sDescriptorHeap.Get()};
    m_commandList->SetDescriptorHeaps(_countof(arrayHeaps), arrayHeaps);
	
// Game.cpp Método Clear. Prepara parámetros

CD3DX12_GPU_DESCRIPTOR_HANDLE cHandle(m_cDescriptorHeap->GetGPUDescriptorHandleForHeapStart());
    //cHandle.Offset(0, m_cDescriptorSize);

    m_commandList->SetGraphicsRootDescriptorTable(0, // número de root parameter
        cHandle); //manejador a la posición del heap donde comenzaría el rango de descriptores
    cHandle.Offset(1, m_cDescriptorSize);
    m_commandList->SetGraphicsRootDescriptorTable(1, // para SRV
        cHandle);

    CD3DX12_GPU_DESCRIPTOR_HANDLE sHandle(m_sDescriptorHeap->GetGPUDescriptorHandleForHeapStart());
    m_commandList->SetGraphicsRootDescriptorTable(2, // número de root parameter
        sHandle); //manejador a la posición del heap donde comenzaría el rango de descriptores
   
// Game.cpp Método Render. Dimensionar correctamente llamada Draw

m_commandList->DrawIndexedInstanced(m_mesh.indices.size(), 1, 0, 0, 0);

// Game.cpp Nuevo input - layout. A incorporar en PSO().

 m_inputLayout = {

        {"POSITION",0,DXGI_FORMAT_R32G32B32_FLOAT,0,0,D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA,0},
        {"COLOR",0,DXGI_FORMAT_R32G32B32A32_FLOAT,0,12,D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA,0},
    {"NORMAL",0,DXGI_FORMAT_R32G32B32_FLOAT,0,28,D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA,0},
    {"UV",0,DXGI_FORMAT_R32G32_FLOAT,0,40,D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA,0}
    };

